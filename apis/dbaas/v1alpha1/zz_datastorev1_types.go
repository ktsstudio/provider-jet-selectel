/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DatastoreV1Observation struct {
	Connections map[string]*string `json:"connections,omitempty" tf:"connections,omitempty"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type DatastoreV1Parameters struct {

	// +kubebuilder:validation:Optional
	Config map[string]*string `json:"config,omitempty" tf:"config,omitempty"`

	// +kubebuilder:validation:Optional
	Firewall []FirewallParameters `json:"firewall,omitempty" tf:"firewall,omitempty"`

	// +kubebuilder:validation:Optional
	Flavor []FlavorParameters `json:"flavor,omitempty" tf:"flavor,omitempty"`

	// +kubebuilder:validation:Optional
	FlavorID *string `json:"flavorId,omitempty" tf:"flavor_id,omitempty"`

	// +kubebuilder:validation:Required
	NodeCount *float64 `json:"nodeCount" tf:"node_count,omitempty"`

	// +kubebuilder:validation:Optional
	Pooler []PoolerParameters `json:"pooler,omitempty" tf:"pooler,omitempty"`

	// +kubebuilder:validation:Required
	ProjectID *string `json:"projectId" tf:"project_id,omitempty"`

	// +kubebuilder:validation:Optional
	RedisPassword *string `json:"redisPassword,omitempty" tf:"redis_password,omitempty"`

	// +kubebuilder:validation:Required
	Region *string `json:"region" tf:"region,omitempty"`

	// +kubebuilder:validation:Optional
	Restore []RestoreParameters `json:"restore,omitempty" tf:"restore,omitempty"`

	// +kubebuilder:validation:Required
	SubnetID *string `json:"subnetId" tf:"subnet_id,omitempty"`

	// +kubebuilder:validation:Required
	TypeID *string `json:"typeId" tf:"type_id,omitempty"`
}

type FirewallObservation struct {
}

type FirewallParameters struct {

	// +kubebuilder:validation:Required
	Ips []*string `json:"ips" tf:"ips,omitempty"`
}

type FlavorObservation struct {
}

type FlavorParameters struct {

	// +kubebuilder:validation:Required
	Disk *float64 `json:"disk" tf:"disk,omitempty"`

	// +kubebuilder:validation:Required
	RAM *float64 `json:"ram" tf:"ram,omitempty"`

	// +kubebuilder:validation:Required
	Vcpus *float64 `json:"vcpus" tf:"vcpus,omitempty"`
}

type PoolerObservation struct {
}

type PoolerParameters struct {

	// +kubebuilder:validation:Required
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// +kubebuilder:validation:Required
	Size *float64 `json:"size" tf:"size,omitempty"`
}

type RestoreObservation struct {
}

type RestoreParameters struct {

	// +kubebuilder:validation:Optional
	DatastoreID *string `json:"datastoreId,omitempty" tf:"datastore_id,omitempty"`

	// +kubebuilder:validation:Optional
	TargetTime *string `json:"targetTime,omitempty" tf:"target_time,omitempty"`
}

// DatastoreV1Spec defines the desired state of DatastoreV1
type DatastoreV1Spec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DatastoreV1Parameters `json:"forProvider"`
}

// DatastoreV1Status defines the observed state of DatastoreV1.
type DatastoreV1Status struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DatastoreV1Observation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DatastoreV1 is the Schema for the DatastoreV1s API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,selecteljet}
type DatastoreV1 struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DatastoreV1Spec   `json:"spec"`
	Status            DatastoreV1Status `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DatastoreV1List contains a list of DatastoreV1s
type DatastoreV1List struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DatastoreV1 `json:"items"`
}

// Repository type metadata.
var (
	DatastoreV1_Kind             = "DatastoreV1"
	DatastoreV1_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DatastoreV1_Kind}.String()
	DatastoreV1_KindAPIVersion   = DatastoreV1_Kind + "." + CRDGroupVersion.String()
	DatastoreV1_GroupVersionKind = CRDGroupVersion.WithKind(DatastoreV1_Kind)
)

func init() {
	SchemeBuilder.Register(&DatastoreV1{}, &DatastoreV1List{})
}
